#include "WeightedGraph.h"

WeightedGraph::WeightedGraph() {
}

bool WeightedGraph::readGraphFromFile(string filepath) {
    clear(); // Clear any previous graph

    ifstream file(filepath);
    if (!file.is_open()) {
        return false; // Error trying to open file
    }

    // Reads number of vertices and adjusts structure
    file >> numVertices;
    adjacencyList.resize(numVertices);

    int source, destination, weight;
    while (file >> source >> destination >> weight) {
        addEdge(source, destination, weight);
    }

    file.close();
    return true; // Graph read succesfully
}

void WeightedGraph::addEdge(int source, int destination, int weight) {
    // Undirected graph, so edge is bidirectional
    adjacencyList[source-1].push_back(make_pair(destination, weight));
    adjacencyList[destination-1].push_back(make_pair(source, weight));
    numEdges++;
}

void WeightedGraph::addVertex() {
    adjacencyList.push_back(list<pair<int, int>>());
    numVertices++;
}

// Return a list of neighbors with their respective weights
list<pair<int, int>> WeightedGraph::findNeighbors(int vertex) {
    if (vertex > 0 && vertex <= numVertices) {
        return adjacencyList[vertex-1];
    } else {
        cout << "Invalid vertex!" << endl;
        return list<pair<int, int>>();
    }

}

int WeightedGraph::findDegree(int vertex) {
    if (vertex > 0 && vertex <= numVertices) {
        return adjacencyList[vertex - 1].size();
    } else {
        cout << "Invalid vertex!" << endl;
        return -1;
    }
}

/*  Performs Dijkstra algorithm using vector, returning relevant information on the shortest distances 
    and the spanning tree generated by the search starting from a source vertex up to a destination. If no destination is 
    provided, the search is ran throughout the entire graph. */
DijkstraResult WeightedGraph::dijkstraVector(int source, int destination) {
    DijkstraResult result;

    vector<int> distance(numVertices, INT_MAX); // Initializing all distances as 'infinite'
    vector<int> parent(numVertices, -1);
    vector<bool> visited(numVertices, false);
    
    // Set the distance of the source vertex to 0
    distance[source - 1] = 0;

    // Iterating through vertices
    for (int i = 1; i <= numVertices; i++) {
        int minVertex = -1;

        // Getting vertex with minimum distance from source
        for (int v = 1; v <= numVertices; v++) {
            if (!visited[v - 1] and (minVertex == -1 or distance[v - 1] < distance[minVertex - 1])) {
                minVertex = v;
            }
        }

        if ((minVertex == destination) or // Min distance/path of destination vertex is found
            (distance[minVertex-1] == INT_MAX)) break; // No more reachable nodes
        
        visited[minVertex-1] = true; // Vertex is explored

        for (pair<int, int> neighbor : findNeighbors(minVertex)) {
            int neighborVertex = neighbor.first;
            int neighborWeight = neighbor.second;
            
            if (distance[minVertex - 1] + neighborWeight < distance[neighborVertex - 1]) {
                // Found a shorter path to neighbor
                distance[neighborVertex - 1] = distance[minVertex - 1] + neighborWeight;
                parent[neighborVertex - 1] = minVertex;
            }
        }
    }

    result.visited = visited;
    result.distance = distance;
    result.parent = parent;
    
    return result;
}

/*  Performs Dijkstra algorithm using vector, returning relevant information on the shortest distances 
    and the spanning tree generated by the search starting from a source vertex up to a destination. If no destination is 
    provided, the search is ran throughout the entire graph. */
DijkstraResult WeightedGraph::dijkstraHeap(int source, int destination) {
    DijkstraResult result;

    return result;
}

/*  Returns a pair (first, second):
    first: shortest distance (weight) between source and destination
    second: shortest path (sequence of vertices) between source and destination, including both */
pair<int, list<int>> WeightedGraph::shortestPath(int source, int destination) {
    DijkstraResult dijkstra = dijkstraVector(source, destination);
    int distance = dijkstra.distance[destination-1];

    list<int> path;
    int vertex = destination;
    while (vertex != source){
        path.push_front(vertex);
        vertex = dijkstra.parent[vertex - 1];
    }
    path.push_front(source);

    return {distance, path};
}

void WeightedGraph::clear() {
    adjacencyList.clear();
    numVertices = 0;
    numEdges = 0;
}