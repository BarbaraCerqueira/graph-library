#include "WeightedGraph.h"

WeightedGraph::WeightedGraph() {
}

bool WeightedGraph::readGraphFromFile(string filepath) {
    clear(); // Clear any previous graph

    ifstream file(filepath);
    if (!file.is_open()) {
        return false; // Error trying to open file
    }

    // Reads number of vertices and adjusts structure
    file >> numVertices;
    adjacencyList.resize(numVertices);

    int source, destination, weight;
    while (file >> source >> destination >> weight) {
        addEdge(source, destination, weight);
    }

    file.close();
    return true; // Graph read succesfully
}

void WeightedGraph::addEdge(int source, int destination, int weight) {
    // Undirected graph, so edge is bidirectional
    adjacencyList[source-1].push_back(make_pair(destination, weight));
    adjacencyList[destination-1].push_back(make_pair(source, weight));
    numEdges++;
}

void WeightedGraph::addVertex() {
    adjacencyList.push_back(list<pair<int, int>>());
    numVertices++;
}

// Return a list of neighbors with their respective weights
list<pair<int, int>> WeightedGraph::findNeighbors(int vertex) {
    if (vertex > 0 && vertex <= numVertices) {
        return adjacencyList[vertex-1];
    } else {
        cout << "Invalid vertex!" << endl;
        return list<pair<int, int>>();
    }

}

int WeightedGraph::findDegree(int vertex) {
    if (vertex > 0 && vertex <= numVertices) {
        return adjacencyList[vertex - 1].size();
    } else {
        cout << "Invalid vertex!" << endl;
        return -1;
    }
}

/*  Performs Dijkstra algorithm using vector, returning relevant information on the shortest distances 
    and the spanning tree generated by the search starting from a source vertex up to a destination. If no destination is 
    provided, the search is ran throughout the entire graph. */
DijkstraResult WeightedGraph::dijkstraVector(int source, int destination) {
    DijkstraResult result;

    vector<int> distance(numVertices, INT_MAX); // Initializing all distances as 'infinite'
    vector<int> parent(numVertices, -1);
    vector<bool> visited(numVertices, false);
    
    // Set the distance of the source vertex to 0
    distance[source - 1] = 0;

    // Iterating through vertices
    for (int i = 1; i <= numVertices; i++) {
        int minVertex = -1;

        // Getting vertex with minimum distance from source
        for (int v = 1; v <= numVertices; v++)
            if (!visited[v - 1] and (minVertex == -1 or distance[v - 1] < distance[minVertex - 1])) 
                minVertex = v;

        if ((minVertex == destination) or // Min distance/path of destination vertex is found
            (distance[minVertex-1] == INT_MAX)) break; // No more reachable nodes
        
        visited[minVertex-1] = true; // Vertex is explored

        for (pair<int, int> neighbor : findNeighbors(minVertex)) {
            int neighborVertex = neighbor.first;
            int neighborWeight = neighbor.second;
            
            if (distance[minVertex - 1] + neighborWeight < distance[neighborVertex - 1]) {
                // Found a shorter path to neighbor
                distance[neighborVertex - 1] = distance[minVertex - 1] + neighborWeight;
                parent[neighborVertex - 1] = minVertex;
            }
        }
    }

    result.distance = distance;
    result.parent = parent;
    
    return result;
}

/*  Performs Dijkstra algorithm using vector, returning relevant information on the shortest distances 
    and the spanning tree generated by the search starting from a source vertex up to a destination. If no destination is 
    provided, the search is ran throughout the entire graph. */
DijkstraResult WeightedGraph::dijkstraHeap(int source, int destination) {
    DijkstraResult result;

    // Create a Fibonacci Heap and initialize distances and parent arrays
    FibonacciHeap heap;
    vector<int> distance(numVertices, INT_MAX);
    vector<int> parent(numVertices, -1);

    // Hash Map to maintain references to nodes in the Fibonacci heap
    unordered_map<int, Node*> nodeMap;  

    // Insert all vertices into the heap with infinite distance
    for (int vertex=1; vertex <= numVertices; vertex++){
        nodeMap[vertex] = heap.insert(INT_MAX, vertex);
    }

    // Update distance of the source vertex to 0
    distance[source - 1] = 0;
    heap.decreaseKey(nodeMap[source], 0);

    // Continue until the heap is empty or destination is reached
    while (!heap.isEmpty()) {
        Node* minNode = heap.getMin();
        int minVertex = minNode->value;
        heap.deleteMin();

        // If destination is reached, break out of the loop
        if (minVertex == destination) break;

        // Exploring neighbors of the current vertex
        for (pair<int, int> neighbor : findNeighbors(minVertex)) {
            int neighborVertex = neighbor.first;
            int neighborWeight = neighbor.second;

            int newDistance = distance[minVertex - 1] + neighborWeight;

            if (newDistance < distance[neighborVertex - 1]) {
                // Found a shorter path to neighbor
                distance[neighborVertex - 1] = newDistance;
                parent[neighborVertex - 1] = minVertex;

                // Updated distance in the heap
                heap.decreaseKey(nodeMap[neighborVertex], newDistance);
            }
        }
    }

    result.distance = distance;
    result.parent = parent;

    return result;
}

/*  Returns a pair (first, second):
    first: shortest distance (weight) between source and destination
    second: shortest path (sequence of vertices) between source and destination, including both */
pair<int, list<int>> WeightedGraph::shortestPath(int source, int destination, bool heap) {
    DijkstraResult search;
    if (heap)
        search = dijkstraHeap(source, destination);
    else
        search = dijkstraVector(source, destination);

    int distance = search.distance[destination-1];

    list<int> path;
    int vertex = destination;
    while (vertex != source){
        path.push_front(vertex);
        vertex = search.parent[vertex - 1];
    }
    path.push_front(source);

    return {distance, path};
}

void WeightedGraph::clear() {
    adjacencyList.clear();
    numVertices = 0;
    numEdges = 0;
}