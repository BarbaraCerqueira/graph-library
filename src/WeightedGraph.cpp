#include "WeightedGraph.h"

WeightedGraph::WeightedGraph() {
}

bool WeightedGraph::readGraphFromFile(string filepath) {
    clear(); // Clear any previous graph

    ifstream file(filepath);
    if (!file.good()) {
        return false; // Error reading file
    }

    // Reads number of vertices and adjusts structure
    file >> numVertices;
    adjacencyList.resize(numVertices);

    int source, destination;
    float weight;
    while (file >> source >> destination >> weight) {
        if (weight < 0) negativeWeight = true;
        addEdge(source, destination, weight);
    }

    file.close();
    return true; // Graph read succesfully
}

void WeightedGraph::addEdge(int source, int destination, float weight) {
    // Undirected graph, so edge is bidirectional
    adjacencyList[source-1].push_back(make_pair(destination, weight));
    adjacencyList[destination-1].push_back(make_pair(source, weight));
    numEdges++;
}

void WeightedGraph::addVertex() {
    adjacencyList.push_back(list<pair<int, float>>());
    numVertices++;
}

// Return a list of neighbors with their respective weights
list<pair<int, float>> WeightedGraph::findNeighbors(int vertex) {
    if (vertex > 0 && vertex <= numVertices) {
        return adjacencyList[vertex-1];
    } else {
        cout << "Invalid vertex!" << endl;
        return list<pair<int, float>>();
    }

}

int WeightedGraph::findDegree(int vertex) {
    if (vertex > 0 && vertex <= numVertices) {
        return adjacencyList[vertex - 1].size();
    } else {
        cout << "Invalid vertex!" << endl;
        return -1;
    }
}

/*  Performs Dijkstra algorithm using vector (linear search), returning relevant information on the shortest distances 
    and the spanning tree generated by the search starting from a source vertex up to a destination. If no destination is 
    provided, the search is ran throughout the entire graph. */
DijkstraResult WeightedGraph::dijkstraVector(int source, int destination) {
    DijkstraResult result;

    vector<float> distance(numVertices, INFINITY_FLOAT); // Initializing all distances as 'infinite'
    vector<int> parent(numVertices, -1);
    vector<bool> visited(numVertices, false);
    
    // Set the distance of the source vertex to 0
    distance[source - 1] = 0;

    // Iterating through vertices
    for (int i = 1; i <= numVertices; i++) {
        int minVertex = -1;

        // Getting vertex with minimum distance from source
        for (int v = 1; v <= numVertices; v++)
            if (!visited[v - 1] && (minVertex == -1 || distance[v - 1] < distance[minVertex - 1])) 
                minVertex = v;

        if ((minVertex == destination) || // Min path of destination vertex is found
            (distance[minVertex-1] == INFINITY_FLOAT)) break; // No more reachable nodes
        
        visited[minVertex-1] = true; // Vertex is explored

        for (pair<int, float> neighbor : findNeighbors(minVertex)) {
            int neighborVertex = neighbor.first;
            float neighborWeight = neighbor.second;
            
            float newDistance = distance[minVertex - 1] + neighborWeight;

            if (!visited[neighborVertex - 1] && newDistance < distance[neighborVertex - 1]) {
                // Found a shorter path to neighbor
                distance[neighborVertex - 1] = distance[minVertex - 1] + neighborWeight;
                parent[neighborVertex - 1] = minVertex;
            }
        }
    }

    result.distance = distance;
    result.parent = parent;
    
    return result;
}

/*  Performs Dijkstra algorithm using vector, returning relevant information on the shortest distances 
    and the spanning tree generated by the search starting from a source vertex up to a destination. If no destination is 
    provided, the search is ran throughout the entire graph. */
DijkstraResult WeightedGraph::dijkstraHeap(int source, int destination) {
    DijkstraResult result;

    // Create a Fibonacci Heap and initialize distances and parent arrays
    FibonacciHeap heap;
    vector<float> distance(numVertices, INFINITY_FLOAT);
    vector<int> parent(numVertices, -1);

    // Hash Map to maintain references to nodes in the Fibonacci heap
    unordered_map<int, Node*> nodeMap;

    // Insert all vertices into the heap with infinite distance
    for (int vertex=1; vertex <= numVertices; vertex++){
        nodeMap[vertex] = heap.insert(INFINITY_FLOAT,vertex);
    }

    // Update distance of the source vertex to 0
    distance[source - 1] = 0;
    heap.decreaseKey(nodeMap[source], 0);

    // Continue until the heap is empty or destination is reached
    while (!heap.isEmpty()) {
        Node* minNode = heap.extractMin(); // Remove vertex from heap - Vertex Explored
        int minVertex = minNode->value;
        float minWeight = minNode->key;

        if ((minVertex == destination) || // Min path of destination vertex is found
            (minWeight == INFINITY_FLOAT)) break; // No more reachable nodes

        // Exploring neighbors of the current vertex
        for (pair<int, float> neighbor : findNeighbors(minVertex)) {
            int neighborVertex = neighbor.first;
            float neighborWeight = neighbor.second;

            float newDistance = distance[minVertex - 1] + neighborWeight;

            if (newDistance < distance[neighborVertex - 1]) {
                // Found a shorter path to neighbor
                distance[neighborVertex - 1] = newDistance;
                parent[neighborVertex - 1] = minVertex;

                // Updated distance in the heap
                heap.decreaseKey(nodeMap[neighborVertex], newDistance);
            }
        }
    }

    result.distance = distance;
    result.parent = parent;

    return result;
}

/*  Returns a pair (first, second):
    first: shortest distance (weight) between source and destination
    second: shortest path (sequence of vertices) between source and destination, including both */
pair<float, list<int>> WeightedGraph::shortestPath(int source, int destination, bool heap) {
    if (negativeWeight){
        cout << "Not possible to find shortest path with negative weights yet!" << endl;
        return pair<float, list<int>>();
    }

    DijkstraResult search;
    if (heap) {
        search = dijkstraHeap(source, destination);
    }
    else
        search = dijkstraVector(source, destination);

    float distance = search.distance[destination-1];
    if (distance == INFINITY_FLOAT)
        return {distance, list<int>()};

    list<int> path;
    int vertex = destination;
    while (vertex != source){
        path.push_front(vertex);
        vertex = search.parent[vertex - 1];
    }
    path.push_front(source);

    return {distance, path};
}

int WeightedGraph::getNumVertices() {
    return numVertices;
}

int WeightedGraph::getNumEdges() {
    return numEdges;
}

void WeightedGraph::clear() {
    adjacencyList.clear();
    numVertices = 0;
    numEdges = 0;
}