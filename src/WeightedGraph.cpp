#include "WeightedGraph.h"

WeightedGraph::WeightedGraph(bool isDirected /*= false*/) {
    this->isDirected = isDirected;
}

bool WeightedGraph::readGraphFromFile(string filepath) {
    clear(); // Clear any previous graph

    ifstream file(filepath);
    if (!file.good()) {
        return false; // Error reading file
    }

    // Reads number of vertices and adjusts structure
    file >> numVertices;
    adjacencyList.resize(numVertices);

    int source, destination;
    float weight;
    while (file >> source >> destination >> weight) {
        if (weight < 0) negativeWeight = true;
        addEdge(source, destination, weight);
    }

    file.close();
    return true; // Graph read succesfully
}

/* Copy Constructor */
WeightedGraph::WeightedGraph(const WeightedGraph &other) {
    isDirected = other.isDirected;
    numVertices = other.numVertices;
    numEdges = other.numEdges;
    negativeWeight = other.negativeWeight;

    // Copying the adjacency list
    adjacencyList.clear();  // Clear the existing list, if any
    adjacencyList.resize(numVertices);

    for (int i = 0; i < numVertices; ++i) {
        adjacencyList[i] = other.adjacencyList[i];
    }
}

void WeightedGraph::addEdge(int source, int destination, float weight, float flow) {
    if (source > 0 && source <= numVertices && destination > 0 && destination <= numVertices) {
        adjacencyList[source-1].emplace_back(destination, weight, flow);
        if (!isDirected) {
            adjacencyList[destination-1].emplace_back(source, weight, flow);
        }
        numEdges++;
    }
}

void WeightedGraph::deleteEdge(int source, int destination) {
    if (source > 0 && source <= numVertices && destination > 0 && destination <= numVertices) {
        // Remove the edge from the adjacency list of the source vertex
        adjacencyList[source - 1].remove_if([destination](const WeightedEdge& edge) {
            return edge.destination == destination;
        });

        // If the graph is undirected, also remove the edge from the destination vertex
        if (!isDirected) {
            adjacencyList[destination - 1].remove_if([source](const WeightedEdge& edge) {
                return edge.destination == source;
            });
        }

        numEdges--;  
    } else {
        cout << "Invalid vertices!" << endl;
    }
}

void WeightedGraph::addVertex() {
    adjacencyList.push_back(list<WeightedEdge>());
    numVertices++;
}

// Return a list of neighbors with their respective weights
list<WeightedEdge>& WeightedGraph::findNeighbors(int vertex) {
    if (vertex > 0 && vertex <= numVertices) {
        return adjacencyList[vertex-1];
    } else {
        cout << "Invalid vertex!" << endl;
        static list<WeightedEdge> emptyList;
        return emptyList;
    }
}

int WeightedGraph::findDegree(int vertex) {
    if (vertex > 0 && vertex <= numVertices) {
        return adjacencyList[vertex - 1].size();
    } else {
        cout << "Invalid vertex!" << endl;
        return -1;
    }
}

/*  Performs Dijkstra algorithm using vector (linear search), returning relevant information on the shortest distances 
    and the spanning tree generated by the search starting from a source vertex up to a destination. If no destination is 
    provided, the search is ran throughout the entire graph. */
DijkstraResult WeightedGraph::dijkstraVector(int source, int destination) {
    DijkstraResult result;

    vector<float> distance(numVertices, INFINITY_FLOAT); // Initializing all distances as 'infinite'
    vector<int> parent(numVertices, -1);
    vector<bool> visited(numVertices, false);
    
    // Set the distance of the source vertex to 0
    distance[source - 1] = 0;

    // Iterating through vertices
    for (int i = 1; i <= numVertices; i++) {
        int minVertex = -1;

        // Getting vertex with minimum distance from source
        for (int v = 1; v <= numVertices; v++)
            if (!visited[v - 1] && (minVertex == -1 || distance[v - 1] < distance[minVertex - 1])) 
                minVertex = v;

        if ((minVertex == destination) || // Min path of destination vertex is found
            (distance[minVertex-1] == INFINITY_FLOAT)) break; // No more reachable nodes
        
        visited[minVertex-1] = true; // Vertex is explored

        for (WeightedEdge& neighbor : findNeighbors(minVertex)) {
            int neighborVertex = neighbor.destination;
            float neighborWeight = neighbor.weight;
            
            float newDistance = distance[minVertex - 1] + neighborWeight;

            if (!visited[neighborVertex - 1] && newDistance < distance[neighborVertex - 1]) {
                // Found a shorter path to neighbor
                distance[neighborVertex - 1] = distance[minVertex - 1] + neighborWeight;
                parent[neighborVertex - 1] = minVertex;
            }
        }
    }

    result.distance = distance;
    result.parent = parent;
    
    return result;
}

/*  Performs Dijkstra algorithm using vector, returning relevant information on the shortest distances 
    and the spanning tree generated by the search starting from a source vertex up to a destination. If no destination is 
    provided, the search is ran throughout the entire graph. */
DijkstraResult WeightedGraph::dijkstraHeap(int source, int destination) {
    DijkstraResult result;

    // Create a Fibonacci Heap and initialize distances and parent arrays
    FibonacciHeap heap;
    vector<float> distance(numVertices, INFINITY_FLOAT);
    vector<int> parent(numVertices, -1);

    // Hash Map to maintain references to nodes in the Fibonacci heap
    unordered_map<int, Node*> nodeMap;

    // Insert all vertices into the heap with infinite distance
    for (int vertex=1; vertex <= numVertices; vertex++){
        nodeMap[vertex] = heap.insert(INFINITY_FLOAT,vertex);
    }

    // Update distance of the source vertex to 0
    distance[source - 1] = 0;
    heap.decreaseKey(nodeMap[source], 0);

    // Continue until the heap is empty or destination is reached
    while (!heap.isEmpty()) {
        Node* minNode = heap.extractMin(); // Remove vertex from heap - Vertex Explored
        int minVertex = minNode->value;
        float minWeight = minNode->key;

        if ((minVertex == destination) || // Min path of destination vertex is found
            (minWeight == INFINITY_FLOAT)) break; // No more reachable nodes

        // Exploring neighbors of the current vertex
        for (WeightedEdge& neighbor : findNeighbors(minVertex)) {
            int neighborVertex = neighbor.destination;
            float neighborWeight = neighbor.weight;

            float newDistance = distance[minVertex - 1] + neighborWeight;

            if (newDistance < distance[neighborVertex - 1]) {
                // Found a shorter path to neighbor
                distance[neighborVertex - 1] = newDistance;
                parent[neighborVertex - 1] = minVertex;

                // Updated distance in the heap
                heap.decreaseKey(nodeMap[neighborVertex], newDistance);
            }
        }
    }

    result.distance = distance;
    result.parent = parent;

    return result;
}

/*  Returns a pair (first, second):
    first: shortest distance (weight) between source and destination
    second: shortest path (sequence of vertices) between source and destination, including both */
pair<float, list<int>> WeightedGraph::shortestPath(int source, int destination, bool heap) {
    if (negativeWeight){
        cout << "Not possible to find shortest path with negative weights yet!" << endl;
        return pair<float, list<int>>();
    }

    DijkstraResult search;
    if (heap) {
        search = dijkstraHeap(source, destination);
    }
    else
        search = dijkstraVector(source, destination);

    float distance = search.distance[destination-1];
    if (distance == INFINITY_FLOAT)
        return {distance, list<int>()};

    list<int> path;
    int vertex = destination;
    while (vertex != source){
        path.push_front(vertex);
        vertex = search.parent[vertex - 1];
    }
    path.push_front(source);

    return {distance, path};
}

/*  Performs a BFS so as to find a a path from 'source' to 'sink' in residual graph. 
    Returns true if path if found. Also fills parent[] to store the path */
bool WeightedGraph::findAugmentingPath(int source, int sink, vector<int>& parent) {
    vector<bool> visited(numVertices, false);

    // Queue for BFS
    queue<int> queue;
    parent[source-1] = 0; // Root has no parent

    visited[source-1] = true;
    queue.push(source);

    while (!queue.empty()) {
        int currentVertex = queue.front();
        queue.pop();

        for (WeightedEdge& neighbor : findNeighbors(currentVertex)) {
            int neighborVertex = neighbor.destination;

            if (!visited[neighborVertex-1]) {
                visited[neighborVertex-1] = true;
                parent[neighborVertex-1] = currentVertex; 

                if (neighborVertex == sink) // Path from source to sink found, stop BFS
                    return true;
                
                queue.push(neighborVertex);
            }
        }
    }

    return false; // Sink cannot be reached from source
}

pair<float, vector<list<WeightedEdge>>> WeightedGraph::fordFulkerson(int source, int sink, bool outputToFile) {
    // Create residual graph using original graph's capacities
    WeightedGraph residualGraph = *this;

    // Innitialization
    vector<int> parent(numVertices, -1);
    float maxFlow = 0; // There is no flow initially
    clearFlow();

    // Augment the flow while there is path from source to sink
    while (residualGraph.findAugmentingPath(source, sink, parent)) {
        // Find bottleneck
        float pathFlow = INFINITY_FLOAT;
        for (int v = sink; v != source; v = parent[v-1]) {
            int u = parent[v-1];
            pathFlow = min(pathFlow, residualGraph.getResidualCapacity(u, v));
        }

        // Update residual capacities of the edges and reverse edges along the path
        for (int v = sink; v != source; v = parent[v-1]) {
            int u = parent[v-1];
            residualGraph.updateResidualCapacity(u, v, -pathFlow);
            residualGraph.updateResidualCapacity(v, u, pathFlow);
            updateFlow(u, v, pathFlow); // Keep track of flow allocation
        }

        // Add path flow to overall flow
        maxFlow += pathFlow;
    }

    if (outputToFile) {
        outputFlowToFile();
    }

    // Return the overall flow
    return {maxFlow, adjacencyList};
}

float WeightedGraph::getResidualCapacity(int startEdge, int endEdge) {
    for (WeightedEdge edge : findNeighbors(startEdge)) {
        if (edge.destination == endEdge)
            return edge.weight;
    }
    return 0;  // If no edge found, residual capacity is 0
}

void WeightedGraph::updateResidualCapacity(int startEdge, int endEdge, float flow) {
    for (WeightedEdge& edge : findNeighbors(startEdge)) {
        if (edge.destination == endEdge) {
            edge.weight += flow;

            if (edge.weight == 0) // Edges with 0 capacity will not be represented in the graph
                deleteEdge(startEdge, endEdge);

            return;
        }
    }
    addEdge(startEdge, endEdge, flow); // If edge not found, create it
}

void WeightedGraph::updateFlow(int startEdge, int endEdge, float flow) {
    for (WeightedEdge& edge : findNeighbors(startEdge)) {
        if (edge.destination == endEdge) {
            edge.flow += flow;
            return;
        }
    }
    return; // If edge is not found, that was a reverse edge and nothing is done
}

void WeightedGraph::clearFlow() {
    for (int vertex = 1; vertex <= numVertices; vertex++) {
        for (WeightedEdge& edge : adjacencyList[vertex-1]) {
            edge.flow = 0;
        }
    }
}

void WeightedGraph::outputFlowToFile() {
    ofstream outputFile("flow_allocation.txt");
    if (!outputFile.good()) {
        cerr << "Error trying to write on file." << endl;
        return;
    }

    for (int vertex = 1; vertex <= numVertices; vertex++) {
        for (WeightedEdge edge : findNeighbors(vertex)) {
            outputFile << vertex << " " << edge.destination << " " << edge.flow << "\n";
        }
    }

    outputFile.close();
}

int WeightedGraph::getNumVertices() {
    return numVertices;
}

int WeightedGraph::getNumEdges() {
    return numEdges;
}

void WeightedGraph::clear() {
    adjacencyList.clear();
    numVertices = 0;
    numEdges = 0;
}